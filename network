/**


*/

//下标全部从零开始

#include <iostream>
#include <cstdio>
#include <cstring>
#include <cstdlib>
#include <cmath>
#include <algorithm>
#include <set>
#include <queue>
#include <stack>
#include <map>
#include <vector>
#include <ctime>
using namespace std;
typedef long long ll;
typedef unsigned long long ull;
typedef pair<int, int> P;

const int maxv = 20000;

const int MAX_CHILD_NUM = 50;   //一个节点的孩子数目上限

const int MAX_CHILD_SERVER_NUM = 40;//一个ToR switch下的server数目上限
const int MAX_CHILD_RACK_NUM = 40;  //一个aggregation switch下的rack数目上限
const int MAX_CHILD_POD_NUM = 10;   //一个core switch下的pod数目上限
const int MAX_VC_VM_NUM = 10;       //一个VC下的VM数目上限
const int MAX_VC_EDGE_NUM = 1000;   //一个VC下的VM间流量通路数目的上限
const int MAX_VC_TEMPLATE = 100;    //VC模板的上限

/*定义物理结构的三种资源的上限*/
const int MAX_SERVER_CPU = 64;
//const int MAX_SERVER_MEMORY = 32 * 1024;    //单位：MB
const int MAX_SERVER_MEMORY = 32;    //单位：单位内存
const int MAX_SERVER_UPBANDWIDTH = 1 * 1024;//单位：MB
const int UPBANDWIDTH_LAMBDA1 = 1;          //这里两个lambda的定义参见kraken论文
const int UPBANDWIDTH_LAMBDA2 = 1;

const int INF = 0x7fffffff;

struct Server
{
    int id;
    int cpu;            //已使用的cpu资源
    int memory;         //已使用的内存资源
    int upbandwidth;    //已使用的上行带宽资源
    int parent;         //父节点的id号码
}server[maxv], tryserver[maxv];

struct Switch
{
    int id;
    int level;                  //交换机层数，自上往下分别是1、2、3层
    int upbandwidth;            //已使用的上行带宽资源
    int childcnt;               //子节点数目
    int child[MAX_CHILD_NUM];   //子节点的id号码
    int parent;                 //父节点的id号码
}switches[maxv], tryswitches[maxv];

struct VirtualMachine
{
    int id;
    int location;       //对应物理机的id，标识当前虚拟机在哪台物理机上 -1表示未放置
    int cpuCost;        //表示这个虚拟机需要多少cpu资源
    int memoryCost;     //表示这个虚拟机需要多少内存资源
};

//VM间流量通路
struct FlowLink
{
    int u, v;           //对应虚拟机的id，分别标识一条边的两个端点
    int bandwidthCost;  //表示这条边需要预留多少流量
};

//VM间流量通路的邻接链表形式（为了简化计算）
struct Edge
{
    int to, bandwidthCost, next;
};

struct VirtualCluster
{
    int id;
    int vmCnt;                          //VC下的VM数目
    VirtualMachine vm[MAX_VC_VM_NUM];   //VC下的VM
    int edgeCnt;                        //VC下的VM间流量通路的数目
    FlowLink link[MAX_VC_EDGE_NUM];     //VC下的VM间流量通路
    int leftTime;

    //增加邻接链表的存储方式
    int head[MAX_VC_VM_NUM];
    int si = 0;
    Edge edge[MAX_VC_EDGE_NUM];
}vc[maxv], vcTemplate[MAX_VC_TEMPLATE];

struct Request
{
    int vcId;           //对应VirtualCluster的id，表明当前操作是对哪个VC进行
    int mode;           //表示当前操作的类型   0：改变特定VM的cpu资源
                        //                        1：改变特定VM的memory资源
                        //                        2：改变特定edge的bandwidth资源
    int subId;          //针对mode变量给出的操作类型，标识对应点或边的id
    double percentage;  //变化的百分数，比如目标是“减少10%”时，percentage值为“-0.1”
};

struct ScheduleQueNode
{
    int id;
    int waitSetSize;
    int waitSet[MAX_VC_VM_NUM]; //桶排思想，waitSet[i]==1 表示当前VC的第i个vm还未被放置（等待中）
                                //waitSet[i]==0 表示当前VC的第i个vm已被放置
    int settleSetSize;
    int settleSet[MAX_VC_VM_NUM];//理同waitSet,settle[i]==1 表示当前VC的第i个vm已被放置在当前节点之下

    //set<int> waitSet;
    void init(int id, int vmCnt, const int waitSet[], const int settleSet[])
    {
        this->id = id;
        this->waitSetSize = 0;
        for(int i = 0; i < vmCnt; i++)
        {
            this->waitSet[i] = waitSet[i];
            if(this->waitSet[i] == 1)
                this->waitSetSize++;
        }
        this->settleSetSize = 0;
        for(int i = 0; i < vmCnt; i++)
        {
            this->settleSet[i] = settleSet[i];
            if(this->settleSet[i] == 1)
                this->settleSetSize++;
        }
    }

    void update(int vmCnt, const int waitSet[], const int settleSet[])
    {
        for(int i = 0; i < vmCnt; i++)
        {
            if(waitSet[i] == 1)
            {
                this->waitSet[i] = waitSet[i];
                this->waitSetSize++;
            }
            if(settleSet[i] == 1)
            {
                this->settleSet[i] = settleSet[i];
                this->settleSetSize++;
            }
        }
    }

};

bool visited[2][maxv];   //记录服务器和交换机是否被访问过的标记数组，第0维标记服务器，第1维标记交换机

/*==========================Initialization==========================*/
int servercnt;
int switchcnt;
int vccnt;
int vctpltcnt;  //vc template count

void init()
{
    servercnt = 0;
    switchcnt = 0;
    vccnt = 0;
    vctpltcnt = 0;
    //newReqSeqPtr = 0;
    //scaleReqSeqPtr = 0;

    //TODO：考虑：或许等到创建的时候再初始化？
    //初始化VC邻接表
    for(int i = 0; i < maxv; i++)
    {
        vc[i].si = 0;
        memset(vc[i].head, -1, sizeof(vc[i].head));
        memset(vc[i].edge, -1, sizeof(vc[i].edge));
    }
    for(int i = 0; i < MAX_VC_TEMPLATE; i++)
    {
        vcTemplate[i].si = 0;
        memset(vcTemplate[i].head, -1, sizeof(vcTemplate[i].head));
        memset(vcTemplate[i].edge, -1, sizeof(vcTemplate[i].edge));
    }
}

void addServer(int parent, int cpu, int memory, int upbandwidth)
{
    server[servercnt].id = servercnt;
    server[servercnt].cpu = cpu;
    server[servercnt].memory = memory;
    server[servercnt].upbandwidth = upbandwidth;
    server[servercnt].parent = parent;
    switches[parent].child[switches[parent].childcnt++] = servercnt;    //更新父节点的子节点信息
    servercnt++;
}

void addSwitch(int parent, int upbandwidth) //如果无父节点，则parent值为-1
{
    if(parent != -1)
        switches[switchcnt].level = switches[parent].level + 1;
    else
        switches[switchcnt].level = 1;

    switches[switchcnt].id = switchcnt;
    switches[switchcnt].parent = parent;
    switches[switchcnt].upbandwidth = upbandwidth;
    if(parent != -1)    //更新父节点的孩子信息
        switches[parent].child[switches[parent].childcnt++] = switchcnt;
    switches[switchcnt].childcnt = 0;
    switchcnt++;
}

void build()
{
    /*===================建立物理拓扑=============================*/
    addSwitch(-1, 0);   //core switch
    int parentCoreSwitchId = switchcnt - 1;
    for(int i = 0; i < MAX_CHILD_POD_NUM; i++)    //recursively buliding
    {
        addSwitch(parentCoreSwitchId, MAX_SERVER_UPBANDWIDTH *
                  MAX_CHILD_SERVER_NUM * MAX_CHILD_RACK_NUM /
                  UPBANDWIDTH_LAMBDA2);
        int parentAggregationSwitchId = switchcnt - 1;
        for(int j = 0; j < MAX_CHILD_RACK_NUM; j++)
        {
            addSwitch(parentAggregationSwitchId, MAX_SERVER_UPBANDWIDTH *
                      MAX_CHILD_SERVER_NUM / UPBANDWIDTH_LAMBDA1);
            int parentTORSwitchId = switchcnt - 1;
            for(int k = 0; k < MAX_CHILD_SERVER_NUM; k++)
            {
                addServer(parentTORSwitchId, MAX_SERVER_CPU,
                          MAX_SERVER_MEMORY, MAX_SERVER_UPBANDWIDTH);
            }
        }
    }
}

//第一次从老树把所有内容都完整复制到新树
//只执行一次，之后都会变成增量复制
void firstCopyTryTree()
{
    for(int i = 0; i < servercnt; i++)
    {
        tryserver[i].cpu = server[i].cpu;
        tryserver[i].id = server[i].id;
        tryserver[i].memory = server[i].memory;
        tryserver[i].parent = server[i].parent;
        tryserver[i].upbandwidth = server[i].upbandwidth;
    }
    for(int i = 0; i < switchcnt; i++)
    {
        tryswitches[i].childcnt = switches[i].childcnt;
        for(int j = 0; j < switches[i].childcnt; j++)
            tryswitches[i].child[j] = switches[i].child[j];
        tryswitches[i].id = switches[i].id;
        tryswitches[i].parent = switches[i].parent;
        tryswitches[i].upbandwidth = switches[i].upbandwidth;
    }
}

//VC消亡时，删除网络上该vc所占资源
void deleteVCResource(int vcId)
{
    //更新CPU、MEMORY资源
    for(int i = 0; i < vc[vcId].vmCnt; i++)
    {
        int serverId = vc[vcId].vm[i].location;
        server[serverId] += vc[vcId].vm[i].cpuCost;
        server[serverId] += vc[vcId].vm[i].memoryCost;
    }

    //更新BandWidth资源 依次对边做LCA
    for(int i = 0; i < vc[vcId].edgeCnt; i++)
    {
        int u = vc[vcId].link[i].u;
        int v = vc[vcId].link[i].v;

        int uLoc = vc[vcId].vm[u].location;
        int vLoc = vc[vcId].vm[v].location;
        //server层
        if(uLoc != vLoc)
        {
            server[uLoc].upbandwidth += vc[vcId].link[i].bandwidthCost;
            server[vLoc].upbandwidth += vc[vcId].link[i].bandwidthCost;

            uLoc = server[uLoc].parent;
            vLoc = server[vLoc].parent;
        }
        //switch层
        while(uLoc != vLoc)
        {
            switches[uLoc].upbandwidth += vc[vcId].link[i].bandwidthCost;
            switches[vLoc].upbandwidth += vc[vcId].link[i].bandwidthCost;

            uLoc = switches[uLoc].parent;
            vLoc = switches[vLoc].parent;
        }
    }
}

//用vc来更新老树
void updateFromVC(int vcId) //不再做资源是否满足的判断
{
    //更新CPU、MEMORY资源
    for(int i = 0; i < vc[vcId].vmCnt; i++)
    {
        int serverId = vc[vcId].vm[i].location;
        server[serverId] -= vc[vcId].vm[i].cpuCost;
        server[serverId] -= vc[vcId].vm[i].memoryCost;
    }

    //更新BandWidth资源 依次对边做LCA
    for(int i = 0; i < vc[vcId].edgeCnt; i++)
    {
        int u = vc[vcId].link[i].u;
        int v = vc[vcId].link[i].v;

        int uLoc = vc[vcId].vm[u].location;
        int vLoc = vc[vcId].vm[v].location;
        //server层
        if(uLoc != vLoc)
        {
            server[uLoc].upbandwidth -= vc[vcId].link[i].bandwidthCost;
            server[vLoc].upbandwidth -= vc[vcId].link[i].bandwidthCost;

            uLoc = server[uLoc].parent;
            vLoc = server[vLoc].parent;
        }
        //switch层
        while(uLoc != vLoc)
        {
            switches[uLoc].upbandwidth -= vc[vcId].link[i].bandwidthCost;
            switches[vLoc].upbandwidth -= vc[vcId].link[i].bandwidthCost;

            uLoc = switches[uLoc].parent;
            vLoc = switches[vLoc].parent;
        }
    }
}

//用来以增量的形式记录新树的修改位置（即“新树和老树的区别”）
int trytreeServerUpdateLocCnt;
int trytreeServerUpdateLoc[maxv];
int trytreeSwitchUpdateLocCnt;
int trytreeSwitchUpdateLoc[maxv];

//用新树更新老树
//更新成功时调用
void updateFromTryTree()
{
    for(int i = 0; i < trytreeServerUpdateLocCnt; i++)
    {
        int loc = trytreeServerUpdateLoc[i];
        server[loc].cpu = tryserver[loc].cpu;
        server[loc].memory = tryserver[loc].memory;
        server[loc].upbandwidth = tryserver[loc].upbandwidth;
    }
    for(int i = 0; i < trytreeSwitchUpdateLocCnt; i++)
    {
        int loc = trytreeSwitchUpdateLoc[i];
        switches[loc].upbandwidth = tryswitches[loc].upbandwidth;
    }
    trytreeServerUpdateLocCnt = 0;
    trytreeSwitchUpdateLocCnt = 0;
}

//用老树还原新树
//更新失败时调用
void rollbackTryTree()
{
    for(int i = 0; i < trytreeServerUpdateLocCnt; i++)
    {
        int loc = trytreeServerUpdateLoc[i];
        tryserver[loc].cpu = server[loc].cpu;
        tryserver[loc].memory = server[loc].memory;
        tryserver[loc].upbandwidth = server[loc].upbandwidth;
    }
    for(int i = 0; i < trytreeSwitchUpdateLocCnt; i++)
    {
        int loc = trytreeSwitchUpdateLoc[i];
        tryswitches[loc].upbandwidth = switches[loc].upbandwidth;
    }
    trytreeServerUpdateLocCnt = 0;
    trytreeSwitchUpdateLocCnt = 0;
}

void vcAddEdge(VirtualCluster& vc, int u, int v, int cost)
{
    //邻接表加双向边
    vc.edge[vc.si].to = v;
    vc.edge[vc.si].bandwidthCost = cost;
    vc.edge[vc.si].next = vc.head[u];
    vc.head[u] = vc.si++;
    vc.edge[vc.si].to = u;
    vc.edge[vc.si].bandwidthCost = cost;
    vc.edge[vc.si].next = vc.head[v];
    vc.head[v] = vc.si++;
}

void loadVcTemplate()   //记录除了vmLoc以外的所有信息
{
    FILE *fin = fopen("VCtemplate.txt", "r");
    int T;
    fscanf(fin, "%d", &T);
    while(T--)
    {
        int n, m;
        fscanf(fin, "%d%d", &n, &m);
        vcTemplate[vctpltcnt].vmCnt = n;
        vcTemplate[vctpltcnt].edgeCnt = m;

        for(int i = 0; i < n; i++)
        {
            int cpu, memory;
            scanf("%d%d", &cpu, &memory);
            vcTemplate[vctpltcnt].vm[i].id = i;
            vcTemplate[vctpltcnt].vm[i].location = -1;
            vcTemplate[vctpltcnt].vm[i].cpuCost = cpu;
            vcTemplate[vctpltcnt].vm[i].memoryCost = memory;
        }

        for(int i = 0; i < m; i++)
        {
            int u, v, cost;
            fscanf(fin, "%d%d", &u, &v, &cost);
            vcTemplate[vctpltcnt].link[i].u = u;
            vcTemplate[vctpltcnt].link[i].v = v;
            vcTemplate[vctpltcnt].link[i].bandwidthCost = cost;
            vcAddEdge(vcTemplate[vctpltcnt], u, v, cost);
            vctpltcnt++;
        }
    }

    fclose(fin);
}

/*===================Request Generator==========================*/
const int MAX_REQ_NUM = 100000;
const int SCALE_REQ_SEQ_NUM = 6;
const int SCALE_REQ_MODE_NUM = 6;   //scale-up/scale-down请求中可能变化的模式
const double CPU_CHANGE_FACTOR = 1.5;          //依据kraken论文中，设置资源的变化率
const double MEMORY_CHANGE_FACTOR = 1.5;
const double BANDWIDTH_CHANGE_FACTOR = 1.5;

double tmpPoissonSeq[MAX_REQ_NUM];
int newReqPoissonSeq[MAX_REQ_NUM];
int scaleReqPoissonSeq[SCALE_REQ_SEQ_NUM][MAX_REQ_NUM];
int newReqSeqPtr;
int scaleReqSeqPtr;
set<int> activeVc;
int activeVcCnt;

multimap<int, int> vcEndCheck;

double randomExponential(double lambda) //生成负指数分布
{
    double pV = 0.0;
    while(true)
    {
        pV = (double)rand() / (double)RAND_MAX;
        if (pV != 1)
        {
            break;
        }
    }
    pV = (-1.0 / lambda) * log(1 - pV);
    return pV;
}

void generatePoissonSeq()
{
    for(int i = 1; i < MAX_REQ_NUM; i++)
        tmpPoissonSeq[i] = tmpPoissonSeq[i-1] + randomExponential(0.36);
    for(int i = 0; i < MAX_REQ_NUM; i++)    //取天花板数，保证在整点时刻处理请求
        newReqPoissonSeq[i] = ceil(tmpPoissonSeq[i]);

    for(int i = 0; i < SCALE_REQ_SEQ_NUM; i++)
    {
        for(int j = 1; j < MAX_REQ_NUM; j++)
            tmpPoissonSeq[i] = tmpPoissonSeq[i-1] + randomExponential(0.36);
        for(int j = 0; j < MAX_REQ_NUM; j++)
            scaleReqPoissonSeq[i][j] = ceil(tmpPoissonSeq[i]);
    }
}

//直接在vc数组创建一个元素
//等放置的时候判断能不能放：如果不能，把lefttime置0
int generateNewReq(int curTime) //-1：无请求 否则返回新创建的vc编号
{
    if(newReqPoissonSeq[newReqSeqPtr] == curTime)
    {
        newReqSeqPtr++;

        int tpltId = rand() % vctpltcnt;    //随机取一个模板
        vc[vccnt].id = vccnt;
        vc[vccnt].leftTime = randomExponential((double)1 / 3600);   //依据kraken论文的说法，是依据均值3600的指数分布去生成随机数

        vcEndCheck.insert(pair<int, int>(curTime + vc[vccnt].leftTime, vccnt)); //计算出消亡的时间点，存入vcEndCheck

        vc[vccnt].vmCnt = vcTemplate[tpltId].vmCnt;
        vc[vccnt].edgeCnt = vcTemplate[tpltId].edgeCnt;
        vc[vccnt].si = vcTemplate[tpltId].si;
        for(int i = 0; i < vc[vccnt].vmCnt; i++)
        {
            vc[vccnt].vm[i].id = vcTemplate[tpltId].vm[i].id;
            vc[vccnt].vm[i].location = vcTemplate[tpltId].vm[i].location;
            vc[vccnt].vm[i].cpuCost = vcTemplate[tpltId].vm[i].cpuCost;
            vc[vccnt].vm[i].memoryCost = vcTemplate[tpltId].vm[i].memoryCost;
        }
        for(int i = 0; i < vc[vccnt].vmCnt; i++)
            vc[vccnt].head[i] = vcTemplate[tpltId].head[i];
        for(int i = 0; i < vc[vccnt].edgeCnt; i++)
        {
            vc[vccnt].link[i].u = vcTemplate[tpltId].link[i].u;
            vc[vccnt].link[i].v = vcTemplate[tpltId].link[i].v;
            vc[vccnt].link[i].bandwidthCost = vcTemplate[tpltId].link[i].bandwidthCost;
        }
        for(int i = 0; i < vc[vccnt].si; i++)
        {
            vc[vccnt].edge[i].to = vcTemplate[tpltId].edge[i].to;
            vc[vccnt].edge[i].next = vcTemplate[tpltId].edge[i].next;
            vc[vccnt].edge[i].bandwidthCost = vcTemplate[tpltId].edge[i].bandwidthCost;
        }

        return vccnt - 1;
    }
    else
        return -1;
}

//先把该vc的信息存到一个临时缓冲区，更新VC和对应服务器的各参数
//等放置的时候再判能不能放：如果不能，还原vc信息，还原服务器信息
VirtualCluster vcPreState;  //暂存进行弹性伸缩的虚拟机的原状态
int generateScaleReq(int processId, int curTime, int &reqMode)   //-1：无请求 否则返回修改的vc编号
{
    if(scaleReqPoissonSeq[processId][scaleReqSeqPtr] == curTime)
    {
        //随机选取一个活跃的vc
        int activeVcId = rand() % activeVcCnt;
        set<int>::iterator iter = activeVc.begin();
        //TODO:可能存在进一步优化的方法
        for(int i = 0; i < activeVcId; i++)
            iter++;
        int vcId = *iter;

        //把VC的原状态(只需要关注三种资源）存到一个缓冲区
        vcPreState.id = vc[vcId].id;
        vcPreState.si = vc[vcId].si;
        vcPreState.vmCnt = vc[vcId].vmCnt;
        vcPreState.edgeCnt = vc[vcId].edgeCnt;
        for(int i = 0; i < vcPreState.vmCnt; i++)
        {
            vcPreState.vm[i].id = vc[vcId].vm[i].id;
            vcPreState.vm[i].location = vc[vcId].vm[i].location;
            vcPreState.vm[i].cpuCost = vc[vcId].vm[i].cpuCost;
            vcPreState.vm[i].memoryCost = vc[vcId].vm[i].memoryCost;
        }
        for(int i = 0; i < vcPreState.vmCnt; i++)
        {
            vcPreState.head[i] = vc[vcId].head[i];
        }
        for(int i = 0; i < vcPreState.edgeCnt; i++)
        {
            vcPreState.link[i].u = vc[vcId].link[i].u;
            vcPreState.link[i].v = vc[vcId].link[i].v;
            vcPreState.link[i].bandwidthCost = vc[vcId].link[i].bandwidthCost;
        }
        for(int i = 0; i < vcPreState.si; i++)
        {
            vcPreState.edge[i].to = vc[vcId].edge[i].to;
            vcPreState.edge[i].next = vc[vcId].edge[i].next;
            vcPreState.edge[i].bandwidthCost = vc[vcId].edge[i].bandwidthCost;
        }

        //把每个VM的location设置为-1，表示当前并没有放置的位置
        for(int i = 0; i < vc[vcId].vmCnt; i++)
        {
            vc[vcId].vm[i].location = -1;
        }


        //更新VC和对应服务器的参数
        //随机选取一种变化的模式
        reqMode = rand() % SCALE_REQ_MODE_NUM;
        switch(reqMode)
        {
            case 0:         //bandwidth upgrade
                for(int i = 0; i < vc[vcId].edgeCnt; i++)
                {
                    vc[vcId].link[i].bandwidthCost = floor(vc[vcId].link[i].bandwidthCost * BANDWIDTH_CHANGE_FACTOR);
                }
                for(int i = 0; i < vc[vcId].si; i++)
                {
                    vc[vcId].edge[i].bandwidthCost = floor(vc[vcId].edge[i].bandwidthCost * BANDWIDTH_CHANGE_FACTOR);
                }
                break;
            case 1:         //bandwidth downgrade
                for(int i = 0; i < vc[vcId].edgeCnt; i++)
                {
                    vc[vcId].link[i].bandwidthCost = floor(vc[vcId].link[i].bandwidthCost / BANDWIDTH_CHANGE_FACTOR);
                }
                for(int i = 0; i < vc[vcId].si; i++)
                {
                    vc[vcId].edge[i].bandwidthCost = floor(vc[vcId].edge[i].bandwidthCost / BANDWIDTH_CHANGE_FACTOR);
                }
                break;
            case 2:         //cpu upgrade
                for(int i = 0; i < vc[vcId].vmCnt; i++)
                {
                    vc[vcId].vm[i].cpuCost = floor(vc[vcId].vm[i].cpuCost * CPU_CHANGE_FACTOR);
                }
                break;
            case 3:         //cpu downgrade
                for(int i = 0; i < vc[vcId].vmCnt; i++)
                {
                    vc[vcId].vm[i].cpuCost = floor(vc[vcId].vm[i].cpuCost / CPU_CHANGE_FACTOR);
                }
                break;
            case 4:         //memory upgrade
                for(int i = 0; i < vc[vcId].vmCnt; i++)
                {
                    vc[vcId].vm[i].memoryCost = floor(vc[vcId].vm[i].memoryCost * MEMORY_CHANGE_FACTOR);
                }
                break;
            case 5:         //memory downgrade
                for(int i = 0; i < vc[vcId].vmCnt; i++)
                {
                    vc[vcId].vm[i].memoryCost = floor(vc[vcId].vm[i].memoryCost / MEMORY_CHANGE_FACTOR);
                }
                break;
        }

        return vcId;
    }
    else
        return -1;
}

/*===========================Scheduler==========================*/

void rollbackVC(int vcId)
{
    //把VC的原状态(只需要关注三种资源）从缓冲区还原出来
    //vc[vcId].id = vcPreState.id;
    //vc[vcId].si = vcPreState.si;
    //vc[vcId].vmCnt = vcPreState.vmCnt;
    //vc[vcId].edgeCnt = vcPreState.edgeCnt;
    for(int i = 0; i < vcPreState.vmCnt; i++)
    {
        //vcPreState.vm[i].id = vc[vcId].vm[i].id;
        vc[vcId].vm[i].location = vcPreState.vm[i].location;
        vc[vcId].vm[i].cpuCost = vcPreState.vm[i].cpuCost;
        vc[vcId].vm[i].memoryCost = vcPreState.vm[i].memoryCost;
    }
    /*for(int i = 0; i < vcPreState.vmCnt; i++)
    {
        vcPreState.head[i] = vc[vcId].head[i];
    }*/
    for(int i = 0; i < vcPreState.edgeCnt; i++)
    {
        //vcPreState.link[i].u = vc[vcId].link[i].u;
        //vcPreState.link[i].v = vc[vcId].link[i].v;
        vc[vcId].link[i].bandwidthCost = vcPreState.link[i].bandwidthCost;
    }
    for(int i = 0; i < vcPreState.si; i++)
    {
        //vcPreState.edge[i].to = vc[vcId].edge[i].to;
        //vcPreState.edge[i].next = vc[vcId].edge[i].next;
        vc[vcId].edge[i].bandwidthCost = vcPreState.edge[i].bandwidthCost;
    }
}

//只在背包问题部分起作用的全局dp数组，开全局是为了加快速度
int knapsackDp[MAX_VC_VM_NUM + 1][MAX_SERVER_CPU][MAX_SERVER_MEMORY];
int knapsackPath[MAX_VC_VM_NUM + 1][MAX_SERVER_CPU][MAX_SERVER_MEMORY];//记录路径，只有两种转移方式，0表示自己转移到自己，1表示选取了上一件物品的转移

void settleInServer(int vcId, int serverId, int waitSet[], int &waitSetSize, int settleSet[], int &settleSetSize)//需要更新waitSetSize的值
{
    visited[0][serverId] = 1;

    //int settleSetSize = 0;
    //int settleSet[MAX_VC_VM_NUM] = {0};

    //knapsackProblem Part
    int tmploc = 0;
    int w1[MAX_VC_VM_NUM], w2[MAX_VC_VM_NUM], v[MAX_VC_VM_NUM];
    int tmpMap[MAX_VC_VM_NUM];              //建立从w、v数组到waitSet的下标映射

    for(int i = 0; i < vc[vcId].vmCnt; i++)
    {
        if(waitSet[i] == 1)
        {
            w1[tmploc] = vc[vcId].vm[i].cpuCost;
            w2[tmploc] = v[tmploc] = vc[vcId].vm[i].memoryCost;
            tmpMap[tmploc] = i;
            tmploc++;
        }
    }

    //memset(knapsackDp, 0, sizeof(knapsackDp));    //只需要初始化一维
    int cpuLimit = tryserver[serverId].cpu;
    int memoryLimit = tryserver[serverId].memory;
    for(int i = 0; i <= cpuLimit; i++)
        for(int j = 0; j <= memoryLimit; j++)
        {
            knapsackDp[waitSetSize][i][j] = 0;
        }

    for(int k = waitSetSize - 1; k >= 0; k--)
        for(int i = 0; i <= cpuLimit; i++)
            for(int j = 0; j <= memoryLimit; j++)
            {
                if(i < w1[k] || j < w2[k])
                {
                    knapsackDp[k][i][j] = knapsackDp[k+1][i][j];
                    knapsackPath[k][i][j] = 0;
                }
                else
                {
                    if(knapsackDp[k+1][i - w1[k]][j - w2[k]] + v[k] > knapsackDp[k+1][i][j])
                    {
                        knapsackDp[k][i][j] = knapsackDp[k+1][i - w1[k]][j - w2[k]] + v[k];
                        knapsackPath[k][i][j] = 1;
                    }
                    else
                    {
                        knapsackDp[k][i][j] = knapsackDp[k+1][i][j];
                        knapsackPath[k][i][j] = 0;
                    }
                }
            }

    int tmpi = cpuLimit;
    int tmpj = memoryLimit;
    for(int k = 0; k < waitSetSize; k++)
    {
        if(knapsackPath[k][tmpi][tmpj] == 1)//选中了当前物品
        {
            settleSet[tmpMap[k]] = 1;   //注意这里要使用映射数组回到waitSet/settleSet那种状态
            //选中了当前物品，说明回溯数组的上一个状态时knapsackPath[k+1][tmpi-w1[k]][tmpj-w2[k]]
            tmpi -= w1[k];
            tmpj -= w2[k];
        }
    }

    //heuristicSearch part
    int b1[MAX_VC_VM_NUM];
    int b2[MAX_VC_VM_NUM];
    int curOutBandwidth = 0;

    //计算对外流量的时候顺便计算B1、B2值
    for(int i = 0; i < vc[vcId].vmCnt; i++)
    {
        if(settleSet[i] == 1)
        {
            b1[i] = b2[i] = 0;
            for(int j = vc[vcId].head[i]; j != -1; j = vc[vcId].edge[j].next)
            {
                int v = vc[vcId].edge[j].to;
                if(settleSet[v] == 1)   //去点在内部
                {
                    b1[i] += vc[vcId].edge[j].bandwidthCost;
                }
                else                    //去点在外部
                {
                    b2[i] += vc[vcId].edge[j].bandwidthCost;
                    curOutBandwidth += vc[vcId].edge[j].bandwidthCost;
                }
            }
        }
    }

    while(settleSetSize > 0 && curOutBandwidth > tryserver[serverId].upbandwidth)
    {
        //根据启发规则进一步删点
        int maxAim = -INF;
        int delLoc = -1;
        for(int i = 0; i < vc[vcId].vmCnt; i++)
        {
            if(settleSet[i] == 1)
            {
                int tmpAim = b2[i] - b1[i];
                if(tmpAim > maxAim)
                {
                    maxAim = tmpAim;
                    delLoc = i;
                }
            }
        }
        settleSet[delLoc] = 0;
        settleSetSize--;

        //重新计算对外流量的时候顺便计算B1、B2值
        curOutBandwidth = 0;
        for(int i = 0; i < vc[vcId].vmCnt; i++)
        {
            if(settleSet[i] == 1)
            {
                b1[i] = b2[i] = 0;
                for(int j = vc[vcId].head[i]; j != -1; j = vc[vcId].edge[j].next)
                {
                    int v = vc[vcId].edge[j].to;
                    if(settleSet[v] == 1)   //去点在内部
                    {
                        b1[i] += vc[vcId].edge[j].bandwidthCost;
                    }
                    else                    //去点在外部
                    {
                        b2[i] += vc[vcId].edge[j].bandwidthCost;
                        curOutBandwidth += vc[vcId].edge[j].bandwidthCost;
                    }
                }
            }
        }
    }

    //用settleSet更新waitSet
    for(int i = 0; i < vc[vcId].vmCnt; i++)
    {
        if(settleSet[i] == 1)
        {
            waitSet[i] = 0;
            waitSetSize--;
        }
    }

    //更新该VC的所有vm的location
    for(int i = 0; i < vc[vcId].vmCnt; i++)
    {
        if(settleSet[i] == 1)
        {
            vc[vcId].vm[i].location = serverId;
        }
    }

    //用settleSet更新资源使用情况
    for(int i = 0; i < vc[vcId].vmCnt; i++) //(内存、cpu）
    {
        if(settleSet[i] == 1)
        {
            tryserver[serverId].cpu -= vc[vcId].vm[i].cpuCost;
            tryserver[serverId].memory -= vc[vcId].vm[i].memoryCost;
        }
    }
    tryserver[serverId].upbandwidth -= curOutBandwidth;//(带宽）

}

void settleInSwitch(int vcId, int switchId, int waitSet[], int &waitSetSize, int settleSet[], int &settleSetSize)
{
    visited[1][switchId] = 1;

    //遍历未访问过的子节点
    for(int i = 0; i < switches[switchId].childcnt && waitSetSize > 0; i++) //未放置完且仍有未访问的子节点
    {
        if(switches[switchId].level == 3)   //说明子节点是服务器
        {
            int childId = switches[switchId].child[i];
            if(visited[0][childId]) //如果当前节点已经被访问过
                continue;

            //todo
            int childSettleSet[MAX_VC_VM_NUM] = {0};
            int childSettleSetSize = 0;
            settleInServer(vcId, childId, waitSet, waitSetSize, childSettleSet, childSettleSetSize);
            for(int i = 0; i < vc[vcId].vmCnt; i++) //合并settleSet
            {
                if(childSettleSet[i] == 1)
                {
                    settleSet[i] = 1;
                    settleSetSize++;
                }
            }
        }
        else    //说明子节点是交换机
        {
            int childId = switches[switchId].child[i];
            if(visited[1][childId])  //如果当前节点已经被访问过
                continue;

            //todo
            int childSettleSet[MAX_VC_VM_NUM] = {0};
            int childSettleSetSize = 0;
            settleInSwitch(vcId, childId, waitSet, waitSetSize, childSettleSet, childSettleSetSize);
            for(int i = 0; i < vc[vcId].vmCnt; i++) //合并settleSet
            {
                if(childSettleSet[i] == 1)
                {
                    settleSet[i] = 1;
                    settleSetSize++;
                }
            }
        }
    }

    //todo:“往下走”地上传

    //计算子节点的上行带宽
    int curOutBandwidth = 0;
    for(int i = 0; i < vc[vcId].vmCnt; i++)
    {
        if(settleSet[i] == 0)//说明这个点在外部
        {
            for(int j = vc[vcId].head[i]; j != -1; j = vc[vcId].edge[j].next)
            {
                int v = vc[vcId].edge[j].to;
                if(settleSet[v] == 1)   //去点在内部
                {
                    curOutBandwidth += vc[vcId].edge[j].bandwidthCost;
                }
            }
        }
    }

    if(curOutBandwidth <= tryswitches[switchId].upbandwidth)    //带宽足够
    {
        //nothing to do
    }
    else    //带宽不足
    {
        //把settleSet中的vm的location信息清空
        for(int i = 0; i < vc[vcId].vmCnt; i++)
        {
            if(settleSet[i] == 1)
            {
                vc[vcId].vm[i].location = -1;
            }
        }

        //把settleSet中的点重新拿到waitSet中
        for(int i = 0; i < vc[vcId].vmCnt; i++)
        {
            if(settleSet[i] == 1)
            {
                waitSet[i] = 1;
                waitSetSize++;
                settleSet[i] = 0;
                settleSetSize--;
            }
        }
    }
}

//返回true表示这个请求可以被满足，返回false表示拒绝这个请求
bool scheduler(int vcId, int reqMode)
{
    //判是否需要迁移,顺便更新新树
    bool needToMigrate = false;

    if(reqMode == 0 || reqMode == 1)
    {
        for(int i = 0; i < vc[vcId].edgeCnt && needToMigrate == false; i++)
        {
            int u = vc[vcId].link[i].u;
            int v = vc[vcId].link[i].v;

            //int tmpStack[10]; //暂存两个节点之间的边，三层交换机的结构下边数不会超过6
            //int tmpStackCnt = 0;

            int uLoc = vc[vcId].vm[u].location;
            int vLoc = vc[vcId].vm[v].location;
            //server层
            if(uLoc != vLoc)
            {
                tryserver[uLoc].upbandwidth -= (vc[vcId].link[i].bandwidthCost - vcPreState.link[i].bandwidthCost);
                tryserver[vLoc].upbandwidth -= (vc[vcId].link[i].bandwidthCost - vcPreState.link[i].bandwidthCost);
                if(tryserver[uLoc].upbandwidth < 0 || tryserver[vLoc].upbandwidth < 0)
                    needToMigrate = true;

                //增量地记录新树的修改位置
                trytreeServerUpdateLoc[trytreeServerUpdateLocCnt++] = uLoc;
                trytreeServerUpdateLoc[trytreeServerUpdateLocCnt++] = vLoc;

                uLoc = tryserver[uLoc].parent;
                vLoc = tryserver[vLoc].parent;
            }
            //switch层
            while(uLoc != vLoc)
            {
                tryswitches[uLoc].upbandwidth -= (vc[vcId].link[i].bandwidthCost - vcPreState.link[i].bandwidthCost);
                tryswitches[vLoc].upbandwidth -= (vc[vcId].link[i].bandwidthCost - vcPreState.link[i].bandwidthCost);
                if(tryswitches[uLoc].upbandwidth < 0 || tryswitches[vLoc].upbandwidth < 0)
                    needToMigrate = true;

                //增量地记录新树的修改位置
                trytreeSwitchUpdateLoc[trytreeSwitchUpdateLocCnt++] = uLoc;
                trytreeSwitchUpdateLoc[trytreeSwitchUpdateLocCnt++] = vLoc;

                uLoc = tryswitches[uLoc].parent;
                vLoc = tryswitches[vLoc].parent;
            }
        }
    }
    else if(reqMode == 2 || reqMode == 3)
    {
        for(int i = 0; i < vc[vcId].vmCnt && needToMigrate == false; i++)
        {
            int serverId = vc[vcId].vm[i].location;
            tryserver[serverId].cpu -= (vc[vcId].vm[i].cpuCost - vcPreState.vm[i].cpuCost);
            if(tryserver[serverId].cpu < 0)
                needToMigrate = true;

            //增量地记录新树的修改位置
            trytreeServerUpdateLoc[trytreeServerUpdateLocCnt++] = serverId;
        }
    }
    else if(reqMode == 4 || reqMode == 5)
    {
        for(int i = 0; i < vc[vcId].vmCnt && needToMigrate == false; i++)
        {
            int serverId = vc[vcId].vm[i].location;
            tryserver[serverId].memory -= (vc[vcId].vm[i].memoryCost - vcPreState.vm[i].memoryCost);
            if(tryserver[serverId].memory < 0)
                needToMigrate = true;

            //增量地记录新树的修改位置
            trytreeServerUpdateLoc[trytreeServerUpdateLocCnt++] = serverId;
        }
    }



    //若不需要迁移（表明请求可以满足），则直接用新树更新老树,退出
    if(needToMigrate == false)
    {
        updateFromTryTree();
        return true;
    }


    //能从这里往下走则说明需要迁移
    rollbackTryTree();

    memset(visited, 0, sizeof(visited));    //清空访问标记数组

    //在新树上删除该VC所占资源
    for(int i = 0; i < vcPreState.vmCnt; i++)
    {
        int loc = vcPreState.vm[i].location;
        tryserver[loc].cpu -= vcPreState.vm[i].cpuCost;
        tryserver[loc].memory -= vcPreState.vm[i].memoryCost;
        trytreeServerUpdateLoc[trytreeServerUpdateLocCnt++] = loc;
    }
    for(int i = 0; i < vcPreState.edgeCnt; i++)
    {
        int u = vcPreState.link[i].u;
        int v = vcPreState.link[i].v;
        int uLoc = vcPreState.vm[u].location;
        int vLoc = vcPreState.vm[v].location;

        //server level
        if(uLoc != vLoc)
        {
            tryserver[uLoc].upbandwidth -= vcPreState.link[i].bandwidthCost;
            tryserver[vLoc].upbandwidth -= vcPreState.link[i].bandwidthCost;
            trytreeServerUpdateLoc[trytreeServerUpdateLocCnt++] = uLoc;
            trytreeServerUpdateLoc[trytreeServerUpdateLocCnt++] = vLoc;
            uLoc = tryserver[uLoc].parent;
            vLoc = tryserver[vLoc].parent;
        }
        //switch level
        while(uLoc != vLoc)
        {
            tryswitches[uLoc].upbandwidth -= vcPreState.link[i].bandwidthCost;
            tryswitches[vLoc].upbandwidth -= vcPreState.link[i].bandwidthCost;
            trytreeSwitchUpdateLoc[trytreeSwitchUpdateLocCnt++] = uLoc;
            trytreeSwitchUpdateLoc[trytreeSwitchUpdateLocCnt++] = vLoc;
            uLoc = tryswitches[uLoc].parent;
            vLoc = tryswitches[vLoc].parent;
        }
    }

    //试放
    bool canMigrate = false;
    queue<ScheduleQueNode> serverque;
    queue<ScheduleQueNode> switchque;
    //遍历一次VC的所有VM，往队列中加服务器
    map<int, int> serverMap;    //serverId离散化，建立从原serverId到离散化后的server的id的映射
    int tmpServerCnt = 0;
    vector<int> tmpvec[MAX_VC_VM_NUM];
    //先按服务器的位置整理出所有vm
    for(int i = 0; i < vcPreState.vmCnt; i++)
    {
        int tmpServerId = vcPreState.vm[i].location;
        if(serverMap.count(tmpServerId) == 1)
        {
            tmpvec[serverMap[tmpServerId]].push_back(i);
        }
        else
        {
            serverMap[tmpServerId] = tmpServerCnt++;
            tmpvec[serverMap[tmpServerId]].push_back(i);
        }
    }
    //把当前vc所用到的服务器及其待放点集加入队列
    for(map<int, int>::iterator it = serverMap.begin(); it != serverMap.end(); it++)    //因为map默认以key值排序，所以这样遍历可以保证顺序访问server
    {
        int tmpSize = tmpvec[it->second].size();
        int tmpWaitSet[MAX_VC_VM_NUM] = {0};
        int tmpSettleSet[MAX_VC_VM_NUM] = {0};
        for(int i = 0; i < tmpSize; i++)
        {
            tmpWaitSet[tmpvec[it->second][i]] = 1;
        }
        ScheduleQueNode tmpNode;
        tmpNode.init(it->first, vc[vcId].vmCnt, tmpWaitSet, tmpSettleSet);
        serverque.push(tmpNode);
    }

    //迭代服务器队列
    ScheduleQueNode parentNode;
    int preParentId = -1;
    while(!serverque.empty())
    {
        ScheduleQueNode cur = serverque.front();
        serverque.pop();
        int serverId = cur.id;

        settleInServer(vcId, serverId, cur.waitSet, cur.waitSetSize, cur.settleSet, cur.settleSetSize);

        //如果当前服务器还不能盛放所有的VM，则要把其父节点压入交换机队列

        if(cur.settleSetSize < vc[vcId].vmCnt)
        {
            if(preParentId == -1)   //第一次进入这个循环
            {
                preParentId = server[serverId].parent;
                parentNode.init(server[serverId].parent, vc[vcId].vmCnt, cur.waitSet, cur.settleSet);
            }
            else if(server[serverId].parent == parentNode.id)//与上一个服务器的父节点相同
            {
                parentNode.update(vc[vcId].vmCnt, cur.waitSet, cur.settleSet);
            }
            else if(server[serverId].parent != parentNode.id)    //与上一个服务器的父节点不同
            {
                switchque.push(parentNode); //压入上一个交换机节点
                preParentId = server[serverId].parent;
                parentNode.init(server[serverId].parent, vc[vcId].vmCnt, cur.waitSet, cur.settleSet);
            }
        }
    }
    switchque.push(parentNode); //压入最后一个交换机节点


    //迭代交换机队列
    preParentId = -1;   //复用上面“迭代服务器”过程的数据结构

    //建立新的waitSet和settleSet
    int newWaitSet[MAX_VC_VM_NUM];
    int newSettleSet[MAX_VC_VM_NUM];

    while(!switchque.empty())
    {
        ScheduleQueNode cur = serverque.front();
        serverque.pop();
        int switchId = cur.id;
        int newWaitSetSize = cur.waitSetSize;
        int newSettleSetSize = cur.settleSetSize;
        for(int i = 0; i < vc[vcId].vmCnt; i++)
        {
            newWaitSet[i] = cur.waitSet[i];
            newSettleSet[i] = cur.settleSet[i];
        }
        settleInSwitch(vcId, switchId, newWaitSet, newWaitSetSize, newSettleSet, newSettleSetSize);
        //settleInSwitch(vcId, switchId, cur.waitSet, cur.waitSetSize, cur.settleSet, cur.settleSetSize);

        //todo
        if(newSettleSetSize == vc[vcId].vmCnt)   //以当前节点为根的子树已经可以盛放所有vm
        {
            canMigrate = true;
            break;
        }
        else if(switches[switchId].level == 1)   //当前已经是交换机的根节点了
        {
            canMigrate = false;
            break;
        }
        else    //以当前节点为根的子树还不能盛放所有vm
        {
            //计算子节点的上行带宽
            int curOutBandwidth = 0;
            for(int i = 0; i < vc[vcId].vmCnt; i++)
            {
                if(newSettleSet[i] == 0)//说明这个点在外部
                {
                    for(int j = vc[vcId].head[i]; j != -1; j = vc[vcId].edge[j].next)
                    {
                        int v = vc[vcId].edge[j].to;
                        if(newSettleSet[v] == 1)   //去点在内部
                        {
                            curOutBandwidth += vc[vcId].edge[j].bandwidthCost;
                        }
                    }
                }
            }

            if(curOutBandwidth <= tryswitches[switchId].upbandwidth)    //带宽足够
            {
                tryswitches[switchId].upbandwidth -= curOutBandwidth;

                //上传
                if(preParentId == -1)   //第一次进入这个循环
                {
                    preParentId = switches[switchId].parent;
                    parentNode.init(switches[switchId].parent, vc[vcId].vmCnt, newWaitSet, newSettleSet);
                }
                else if(switches[switchId].parent == parentNode.id)//与上一个交换机的父节点相同
                {
                    parentNode.update(vc[vcId].vmCnt, newWaitSet, newSettleSet);
                }
                else if(switches[switchId].parent != parentNode.id)    //与上一个交换机的父节点不同
                {
                    switchque.push(parentNode); //压入上一个交换机节点
                    preParentId = switches[switchId].parent;
                    parentNode.init(switches[switchId].parent, vc[vcId].vmCnt, newWaitSet, newSettleSet);
                }

            }
            else    //带宽不足
            {
                //把settleSet中的vm的location信息清空
                for(int i = 0; i < vc[vcId].vmCnt; i++)
                {
                    if(newSettleSet[i] == 1)
                    {
                        vc[vcId].vm[i].location = -1;
                    }
                }

                //把settleSet中的点重新拿到waitSet中
                for(int i = 0; i < vc[vcId].vmCnt; i++)
                {
                    if(newSettleSet[i] == 1)
                    {
                        newWaitSet[i] = 1;
                        newWaitSetSize++;
                        newSettleSet[i] = 0;
                        newSettleSetSize--;
                    }
                }

                //上传
                if(preParentId == -1)   //第一次进入这个循环
                {
                    preParentId = switches[switchId].parent;
                    parentNode.init(switches[switchId].parent, vc[vcId].vmCnt, newWaitSet, newSettleSet);
                }
                else if(switches[switchId].parent == parentNode.id)//与上一个交换机的父节点相同
                {
                    parentNode.update(vc[vcId].vmCnt, newWaitSet, newSettleSet);
                }
                else if(switches[switchId].parent != parentNode.id)    //与上一个交换机的父节点不同
                {
                    switchque.push(parentNode); //压入上一个交换机节点
                    preParentId = switches[switchId].parent;
                    parentNode.init(switches[switchId].parent, vc[vcId].vmCnt, newWaitSet, newSettleSet);
                }
            }
        }

        if(switchque.empty())   //todo：不知道对不对，一个比较抽搐的写法：能走到这里说明迭代还没有结束（上面有个break），而队列为空说明还有一个父节点没有被压入队列
        {
            switchque.push(parentNode); //压入“最后一个”交换机节点
        }
    }

    if(canMigrate == true)
    {
        migCnt++;   //在需要迁移且成功迁移时，统计一下迁移次数
        updateMigMemoryCnt(vcId);

        //updateFromTryTree();
        updateFromVC(vcId);
        return true;
    }
    else if(canMigrate == false)
    {
        rollbackVC(vcId);
        rollbackTryTree();
        return false;
    }
}

//Pleasement
int FFServerPosPtr = 0; //在试图返回-1或1时修改
int FFsettleInSwitch(int vcId, int switchId, int &curVmPos, int intervalLB, int intervalRB, int serverStartPos)  //返回值：0，暂时放置结束 -1放置失败，结束 1放置成功
{
    visited[1][switchId] = !visited[1][switchId];   //为了标记出当前是第几次访问这个交换机

    int preVmPos = curVmPos;    //以备回滚
    int endFlag = 0;    //0:未结束 -1：失败结束 1：成功结束

    //计算进来的带宽是否足够
    int curOutBandwidth = 0;
    if(preVmPos > 0)
    {
        for(int i = vc[vcId].head[preVmPos]; i != -1; i = vc[vcId].edge[i].next)
        {
            if(vc[vcId].edge[i].to == preVmPos - 1)
            {
                curOutBandwidth += vc[vcId].edge[i].bandwidthCost;
                break;
            }
        }
    }
    if(curOutBandwidth > tryswitches[switchId].upbandwidth)
    {
        endFlag = 0；
        return endFlag;
    }

    if(switches[switchId].level == 1)    //子节点是Aggregation Switch
    {
        int curSwitchPos = serverStartPos / MAX_CHILD_RACK_NUM / MAX_CHILD_SERVER_NUM;
        for(int i = 0; i <= switches[switchId].childcnt && endFlag == 0; i++)
        {
            int childId = switches[switchId].child[curSwitchPos];
            int newIntervalLB = intervalLB + MAX_CHILD_RACK_NUM * MAX_CHILD_SERVER_NUM * curSwitchPos;
            int newIntervalRB = newIntervalLB + MAX_CHILD_RACK_NUM * MAX_CHILD_SERVER_NUM - 1;
            endFlag = FFsettleInSwitch(vcId, childId, curVmPos, newIntervalLB, newIntervalRB, serverStartPos);
            curSwitchPos = (curSwitchPos + 1) % switches[switchId].childcnt;
        }
    }
    else if(switches[switchId].level == 2)  //子节点是TOR Switch
    {
        //int curSwitchPos = (serverStartPos % (MAX_CHILD_RACK_NUM * MAX_CHILD_SERVER_NUM)) / MAX_CHILD_SERVER_NUM;

        int curSwitchPos;
        if(intervalLB <= serverStartPos && serverStartPos <= intervalRB && visited[1][switchId] == 1)   //搜索起点在这个区间内并且该节点第一次被访问
            curSwitchPos = (serverStartPos - intervalLB) / MAX_CHILD_SERVER_NUM;
        else
            curSwitchPos = 0;
        for(int i = 0; i <= switches[switchId].childcnt && endFlag == 0; i++)
        {
            int childId = switches[switchId].child[curSwitchPos];
            int newIntervalLB = intervalLB + MAX_CHILD_SERVER_NUM * curSwitchPos;
            int newIntervalRB = newIntervalLB + MAX_CHILD_SERVER_NUM - 1;
            endFlag = FFsettleInSwitch(vcId, childId, curVmPos, newIntervalLB, newIntervalRB, serverStartPos);
            curSwitchPos = (curSwitchPos + 1) % switches[switchId].childcnt;
        }
    }
    else if(switches[switchId].level == 3)  //子节点是服务器
    {
        int curServerPos;
        if(intervalLB <= serverStartPos && serverStartPos <= intervalRB && visited[1][switchId] == 1)   //搜索起点在这个区间内并且该节点第一次被访问
            curServerPos = serverStartPos - intervalLB;
        else
            curServerPos = 0;
        for(int i = 0; i <= switches[switchId].childcnt && endFlag == 0; i++)
        {
            int childId = switches[switchId].child[curServerPos];
            int newIntervalLB = intervalLB + curServerPos;
            int newIntervalRB = newIntervalLB;
            endFlag = FFsettleInServer(vcId, childId, curVmPos, newIntervalLB, newIntervalRB, serverStartPos);
            curServerPos = (curServerPos + 1) % switches[switchId].childcnt;
        }
    }

    if(curVmPos == vc[vcId].vmCnt)  //成功放置，退出循环
    {
        endFlag = 1;
    }
    else if(curVmPos < vc[vcId].vmCnt)
    {
        for(int i = vc[vcId].head[curVmPos]; i != -1; i = vc[vcId].edge[i].next)
        {
            if(vc[vcId].edge[i].to == curVmPos + 1)
            {
                curOutBandwidth += vc[vcId].edge[i].bandwidthCost;
                break;
            }
        }

        if(curOutBandwidth > tryswitches[switchId].upbandwidth) //带宽不足，回滚
            curVmPos = preVmPos;
    }

    return endFlag;
}

int FFsettleInServer(int vcId, int serverId, int curVmPos, int intervalLB, int intervalRB, int serverStartPos)
{
    visited[0][serverId] = 1;

    //计算进来的带宽是否足够
    int curOutBandwidth = 0;
    if(preVmPos > 0)
    {
        for(int i = vc[vcId].head[preVmPos]; i != -1; i = vc[vcId].edge[i].next)
        {
            if(vc[vcId].edge[i].to == preVmPos - 1)
            {
                curOutBandwidth += vc[vcId].edge[i].bandwidthCost;
                break;
            }
        }
    }
    if(curOutBandwidth > tryserver[serverId].upbandwidth)
    {
        endFlag = 0；
        return endFlag;
    }

    //判CPU、MEMORY资源
    int curCpu = 0;
    int curMemory = 0;
    while(curVmPos < vc[vcId].vmCnt && curCpu <= server[serverId].cpu && curMemory <= server[serverId].memory)
    {
        curCpu += vc[vcId].vm[curVmPos].cpuCost;
        curMemory += vc[vcId].vm[curVmPos].memoryCost;
        vc[vcId].vm[curVmPos].location = serverId;  //可能会多修改一个位置，但是没关系，后面会被覆盖掉
        curVmPos++;
    }

    if(curVmPos == vc[vcId].vmCnt)  //成功放置，退出循环
    {
        //更新下次搜索的起始位置
        FFServerPosPtr = (serverId + 1) % (MAX_CHILD_POD_NUM * MAX_CHILD_RACK_NUM * MAX_CHILD_SERVER_NUM);

        return 1;
    }
    else// if(curVmPos < vc[vcId].vmCnt)
    {
        for(int i = vc[vcId].head[curVmPos]; i != -1; i = vc[vcId].edge[i].next)
        {
            if(vc[vcId].edge[i].to == curVmPos + 1)
            {
                curOutBandwidth += vc[vcId].edge[i].bandwidthCost;
                break;
            }
        }

        if(curOutBandwidth > tryserver[serverId].upbandwidth) //带宽不足，回滚
            curVmPos = preVmPos;

        if((server[serverId].id + 1) % (MAX_CHILD_POD_NUM * MAX_CHILD_RACK_NUM * MAX_CHILD_SERVER_NUM) == serverStartPos)
            return -1;  //搜索到起点
        else
            return 0;
    }
}

bool placement(int vcId)
{
    memset(visited, 0, sizeof(visited));    //清空访问标记数组

    if(FFsettleInServer(vcId, 0, 0, 0, MAX_CHILD_POD_NUM * MAX_CHILD_RACK_NUM * MAX_CHILD_SERVER_NUM - 1, FFServerPosPtr) == 1)
    {
        updateFromVC(vcId);
        return true;
    }

    else
        return false;
}

void terminateJudge(int curTime)
{
    pair<multimap<int, int>::iterator, multimap<int, int>::iterator> range;
    range = vcEndCheck.equal_range(curTime);
    for(multimap<int, int>::iterator i = range.first; i != range.second; i++)
    {
        int vcId = i->second;

        //更新activeVC
        activeVc.erase(vcId);
        activeVcCnt--;

        //更新资源使用情况
        deleteVCResource(vcId);
    }
    vcEndCheck.erase(range.first, range.second);
}

//===============evaluation====================
int newReqAcCnt, newReqTotCnt;      //新建请求的计数
int scaleReqAcCnt, scaleReqTotCnt;  //调整请求的计数
int migMemoryCnt;   //迁移总内存
int migCnt;         //迁移总次数
//todo：定义未明
int migTotTime;     //花在迁移的时间

void updateMigMemoryCnt(int vcId)   //更新总的迁移内存数
{
    for(int i = 0; i < vcPreState.vmCnt; i++)
    {
        if(vcPreState.vm[i].location != vc[vcId].vm[i].location)
        {
            migMemoryCnt += vcPreState.vm[i].memoryCost;
        }
    }
}


int main()
{
    srand((unsigned)time(NULL));

    init();
    build();
    loadVcTemplate();

    generatePoissonSeq();

    int totalTime = 10 * 3600;   //程序总运行时间 单位：秒
    int curTime = 0;
    while(curTime < totalTime)
    {
        terminateJudge(curTime);

        int vcId;
        while((vcId = generateNewReq(curTime)) != -1)    //考虑统一时刻可能有多个请求到达
        {
            newReqTotCnt++;
            if(placement(vcId) == true)
                newReqAcCnt++;
        }

        for(int i = 0; i < SCALE_REQ_SEQ_NUM; i++)  //6线程生成
        {
            int vcId, reqMode;
            while((vcId = generateScaleReq(i, curTime, reqMode)) != -1)  //考虑统一时刻可能有多个请求到达
            {
                scaleReqTotCnt++;
                if(scheduler(vcId, reqMode) == true)
                    scaleReqAcCnt++;
            }
        }

        curTime++;
    }


	return 0;
}



